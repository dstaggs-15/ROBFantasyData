<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fantasy League – Standings &amp; Playoff Bracket</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      This page powers the fantasy‑football standings and playoff bracket for
      the ROBFantasyData GitHub Pages site. It reads game results from
      schedule.json (placed alongside this file in the /docs folder) and
      computes win/loss records, points for/against, division winners,
      seeding and a simple estimate of playoff likelihood.  The bracket
      respects a five‑team format: seeds 1–3 receive first‑round byes,
      seeds 4 and 5 play in round 1, and the bracket reseeds before the
      semifinals (lowest remaining seed faces #1, the other faces #2 or #3).

      Styles largely mirror the prior version of the site but have been
      consolidated here for ease of maintenance.  Responsiveness is handled
      via CSS media queries so the table and bracket look good on mobile.
    -->
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top left, #0f172a 0, #020617 45%, #000 100%);
            color: #e5e7eb;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 32px 16px 40px;
        }

        .page { width: 100%; max-width: 1200px; }

        header {
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            gap: 16px;
            align-items: center;
        }

        header h1 { font-size: 1.9rem; letter-spacing: 0.03em; }
        header .subtitle { font-size: 0.95rem; color: #9ca3af; margin-top: 4px; }

        .badge {
            font-size: 0.85rem;
            padding: 6px 14px;
            border-radius: 999px;
            background: linear-gradient(135deg, #22c55e, #38bdf8);
            color: #0f172a;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .grid {
            display: grid;
            grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
            gap: 20px;
        }

        .card {
            background: linear-gradient(145deg, rgba(15,23,42,0.98), rgba(15,23,42,0.85));
            border-radius: 18px;
            border: 1px solid rgba(148,163,184,0.25);
            box-shadow: 0 18px 40px rgba(15,23,42,0.7);
            padding: 18px 20px 18px;
            backdrop-filter: blur(14px);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .card-header h2 { font-size: 1.15rem; letter-spacing: 0.06em; text-transform: uppercase; }

        .pill {
            font-size: 0.75rem;
            padding: 3px 9px;
            border-radius: 999px;
            background: rgba(15,118,110,0.15);
            border: 1px solid rgba(45,212,191,0.4);
            color: #a5f3fc;
            text-transform: uppercase;
        }

        .table-wrapper {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-top: 4px;
        }

        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }

        thead { background: linear-gradient(to right, rgba(56,189,248,0.12), rgba(129,140,248,0.12)); }

        th, td { padding: 6px 7px; text-align: left; white-space: nowrap; }

        th {
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 0.09em;
            color: #9ca3af;
            border-bottom: 1px solid rgba(148,163,184,0.35);
        }

        tbody tr:nth-child(odd) { background: rgba(15,23,42,0.9); }
        tbody tr:nth-child(even) { background: rgba(15,23,42,0.75); }
        tbody tr td:first-child { color: #6b7280; font-size: 0.8rem; }

        .team-name { font-weight: 500; color: #e5e7eb; }

        .tag {
            font-size: 0.78rem;
            padding: 2px 7px;
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.4);
        }
        .tag.div { border-color: rgba(56,189,248,0.6); color: #7dd3fc; }
        .tag.wild { border-color: rgba(52,211,153,0.7); color: #6ee7b7; }
        .tag.out { border-color: rgba(148,163,184,0.5); color: #9ca3af; }

        .side-stack { display: grid; grid-template-rows: auto auto; gap: 14px; }

        .tiebreak-list { font-size: 0.8rem; color: #d1d5db; margin-left: 14px; margin-top: 6px; line-height: 1.45; }
        .tiebreak-list li { margin-bottom: 4px; }

        details.tiebreaker-details {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(15,23,42,0.8);
            border: 1px solid rgba(148,163,184,0.5);
        }

        details.tiebreaker-details summary {
            cursor: pointer;
            list-style: none;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.13em;
            color: #e5e7eb;
        }

        details.tiebreaker-details summary::marker,
        details.tiebreaker-details summary::-webkit-details-marker { display: none; }

        .note { font-size: 0.78rem; color: #9ca3af; margin-top: 10px; line-height: 1.4; }

        .h2h-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 6px 0 8px;
        }

        select, button {
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.7);
            background: rgba(15,23,42,0.9);
            color: #e5e7eb;
            font-size: 0.82rem;
            padding: 5px 10px;
        }

        button {
            cursor: pointer;
            border-color: #38bdf8;
            background: linear-gradient(135deg, #0ea5e9, #22c55e);
            color: #0f172a;
            font-weight: 600;
        }

        button:hover { filter: brightness(1.05); }

        #h2h-result { font-size: 0.82rem; color: #e5e7eb; min-height: 18px; margin-top: 4px; }
        #h2h-note { font-size: 0.75rem; color: #9ca3af; margin-top: 6px; line-height: 1.35; }

        /* PURE LINES BRACKET (SVG) */
        .bracket-svg-wrapper {
            margin-top: 10px;
            border-radius: 14px;
            border: 1px solid rgba(148,163,184,0.35);
            background: #020617;
            padding: 12px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* the svg itself will be generated dynamically via JS */
        .bracket-svg {
            width: 100%;
            height: auto;
            min-width: 520px;
            display: block;
        }

        .svg-team {
            fill: #e5e7eb;
            font-size: 13px;
            font-weight: 600;
        }

        .svg-line {
            stroke: #38bdf8;
            stroke-width: 3;
        }

        .semi-line {
            stroke: #22c55e;
            stroke-width: 3;
        }

        .champ-line {
            stroke: #facc15;
            stroke-width: 3;
        }

        .svg-label {
            fill: #9ca3af;
            font-size: 11px;
        }

        .champ-text {
            fill: #facc15;
            font-size: 15px;
            font-weight: 700;
        }

        .champ-subtext {
            fill: #e5e7eb;
            font-size: 11px;
        }

        @media (max-width: 900px) {
            .grid { grid-template-columns: 1fr; }
            header { flex-direction: column; align-items: flex-start; gap: 6px; }
        }

        @media (max-width: 600px) {
            body { padding: 20px 8px 24px; }
            header h1 { font-size: 1.4rem; }
            header .subtitle { font-size: 0.85rem; }
            .card { padding: 14px 12px 14px; }
            th, td { padding: 5px 5px; font-size: 0.8rem; }
            .h2h-controls { flex-direction: column; align-items: stretch; }
            .h2h-controls select,
            .h2h-controls button { width: 100%; }
            .badge { font-size: 0.75rem; padding: 5px 10px; }
        }
    </style>
</head>
<body>
<div class="page">
    <header>
        <div>
            <h1>Fantasy League – Projected Standings</h1>
            <div class="subtitle">
                Top 3 seeds get a first‑round bye. 5‑team bracket, reseeds each round.
            </div>
        </div>
        <span class="badge" id="week-badge">Loading…</span>
    </header>

    <div class="grid">
        <!-- LEFT: STANDINGS -->
        <div class="card">
            <div class="card-header">
                <h2>League Table</h2>
                <span class="pill">Seeds · PF · PA · Playoff %</span>
            </div>

            <div class="table-wrapper">
                <table>
                    <thead>
                    <tr>
                        <th>#</th>
                        <th>Team</th>
                        <th>Seed</th>
                        <th>Div</th>
                        <th>Record</th>
                        <th>PF</th>
                        <th>PA</th>
                        <th>PO%</th>
                        <th>Status</th>
                    </tr>
                    </thead>
                    <tbody id="standings-body"></tbody>
                </table>
            </div>

            <details class="tiebreaker-details" open>
                <summary> Tie‑breaker &amp; Seeding Notes (click) </summary>
                <ul class="tiebreak-list" id="tiebreak-list">
                    <!-- will be populated dynamically -->
                </ul>
                <p class="note">
                    Playoff % estimates mirror what you see in ESPN: mid‑90s for virtual locks,
                    around 50–60 for bubble teams, and single digits for longshots.
                </p>
            </details>
        </div>

        <!-- RIGHT: BRACKET (LINES ONLY) + H2H -->
        <div class="side-stack">
            <!-- BRACKET -->
            <div class="card">
                <div class="card-header">
                    <h2>Projected Playoff Bracket</h2>
                    <span class="pill">Lines View · 5‑Team</span>
                </div>

                <div class="bracket-svg-wrapper">
                    <div id="bracket-container"><!-- bracket SVG inserted here --></div>
                </div>

                <p class="note">
                    Round 1: only the #4 and #5 seeds play.  Round 2: the bracket
                    <strong>re‑seeds</strong>; lowest remaining seed faces highest (#1) and the
                    next faces #2/#3.  Winners of each semifinal meet in the Championship.
                </p>
            </div>

            <!-- H2H -->
            <div class="card">
                <div class="card-header">
                    <h2>Head‑to‑Head Lookup</h2>
                    <span class="pill">From schedule.json</span>
                </div>
                <p style="font-size:0.84rem;color:#d1d5db;margin-bottom:4px;">
                    Select two teams to see their head‑to‑head record based on games in <code>schedule.json</code>.
                </p>
                <div class="h2h-controls">
                    <select id="teamA"></select>
                    <span style="align-self:center;font-size:0.8rem;color:#9ca3af;">vs</span>
                    <select id="teamB"></select>
                    <button type="button" onclick="showHeadToHead()">Show H2H</button>
                </div>
                <div id="h2h-result"></div>
                <div id="h2h-note">
                    Only completed games (non‑null scores) are counted.  Make sure
                    <code>schedule.json</code> is present in this folder.
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Division identifiers used throughout the code: 1 = Crabs, 2 = Fish.
    const divisionMap = { 1: 'Crabs', 2: 'Fish' };

    // Hard‑coded mapping of team names to divisions.  If divisions change
    // in future seasons, update this object accordingly.  These were
    // derived from the 2025 season summary provided by the commissioner.
    const teamDivisions = {
        'James Teams Sucks': 2,
        'Crip Crip': 1,
        'Dart Party': 1,
        'Duloc InjuredBread Men- 12': 1,
        'HerpesDonator': 2,
        'Our Lard and Savior': 1,
        "Josh's Scary Team": 1,
        'Indoctrinated Ravens': 2,
        'Koolaid Jammer': 2,
        "Don't Blink": 2
    };

    let scheduleData = [];
    let teams = [];

    async function loadSchedule() {
        try {
            const res = await fetch('schedule.json');
            if (!res.ok) throw new Error('HTTP ' + res.status);
            scheduleData = await res.json();
        } catch (err) {
            console.error('Error loading schedule.json:', err);
            const el = document.getElementById('h2h-result');
            if (el) {
                el.textContent = 'Could not load schedule.json – check that it exists next to this HTML file.';
            }
        }
    }

    /**
     * Compute standings based on the loaded schedule.  Each team object
     * returned includes wins, losses, ties, PF, PA, winPct, division,
     * rank, seed, playoffChance, status and tagType.
     */
    function computeStandings() {
        const tmp = {};
        // ensure all teams from the schedule are represented
        scheduleData.forEach(g => {
            [g.home, g.away].forEach(name => {
                if (!tmp[name]) {
                    const divId = teamDivisions[name] || 1;
                    tmp[name] = {
                        name: name,
                        div: divId,
                        wins: 0,
                        losses: 0,
                        ties: 0,
                        pf: 0,
                        pa: 0
                    };
                }
            });
            // only accumulate stats for completed games
            if (g.homeScore != null && g.awayScore != null) {
                // Points for and against
                tmp[g.home].pf += g.homeScore;
                tmp[g.home].pa += g.awayScore;
                tmp[g.away].pf += g.awayScore;
                tmp[g.away].pa += g.homeScore;
                // Win/loss/tie
                if (g.homeScore > g.awayScore) {
                    tmp[g.home].wins++;
                    tmp[g.away].losses++;
                } else if (g.homeScore < g.awayScore) {
                    tmp[g.away].wins++;
                    tmp[g.home].losses++;
                } else {
                    tmp[g.home].ties++;
                    tmp[g.away].ties++;
                }
            }
        });

        // convert to array and compute derived metrics
        let list = Object.values(tmp);
        list.forEach(t => {
            const games = t.wins + t.losses + t.ties;
            const wpct = games ? (t.wins + 0.5 * t.ties) / games : 0;
            t.games = games;
            t.winPct = wpct;
            t.record = `${t.wins}\u2013${t.losses}` + (t.ties ? `\u2013${t.ties}` : '');
        });

        // determine division winners: highest winPct then PF
        const divisionWinners = {};
        list.forEach(t => {
            const d = t.div;
            if (!divisionWinners[d] || divisionWinners[d].winPct < t.winPct ||
                (divisionWinners[d].winPct === t.winPct && divisionWinners[d].pf < t.pf)) {
                divisionWinners[d] = t;
            }
        });
        // assign seeds to division winners (#1 and #2)
        const champs = Object.values(divisionWinners).sort((a, b) => {
            if (b.winPct !== a.winPct) return b.winPct - a.winPct;
            return b.pf - a.pf;
        });
        champs.forEach((t, idx) => {
            t.seed = idx + 1;
        });
        // remove winners from pool
        const remaining = list.filter(t => !champs.includes(t));
        // sort remaining by winPct then PF
        remaining.sort((a, b) => {
            if (b.winPct !== a.winPct) return b.winPct - a.winPct;
            return b.pf - a.pf;
        });
        // assign seeds 3–5
        if (remaining[0]) remaining[0].seed = 3;
        if (remaining[1]) remaining[1].seed = 4;
        if (remaining[2]) remaining[2].seed = 5;
        // compute rank ordering by winPct then PF
        const sortedAll = list.slice().sort((a, b) => {
            if (b.winPct !== a.winPct) return b.winPct - a.winPct;
            return b.pf - a.pf;
        });
        sortedAll.forEach((t, idx) => {
            t.rank = idx + 1;
        });
        // playoff chances and statuses
        list.forEach(t => {
            if (t.seed) {
                if (t.seed <= 3) {
                    // division champ if top seeds matches division winner
                    const isChamp = champs.includes(t);
                    t.status = `${isChamp ? divisionMap[t.div] + ' Champ · ' : ''}#${t.seed} Seed · Bye`;
                    t.tagType = isChamp ? 'div' : 'wild';
                    // high probability for bye teams: 95, 85, 75
                    const base = 95 - (t.seed - 1) * 10;
                    t.playoffChance = Math.max(50, Math.min(99, Math.round(base)));
                } else if (t.seed === 4) {
                    t.status = `#4 Seed · Plays #5`;
                    t.tagType = 'wild';
                    t.playoffChance = 55;
                } else if (t.seed === 5) {
                    t.status = `#5 Seed · Plays #4`;
                    t.tagType = 'wild';
                    t.playoffChance = 50;
                }
            } else {
                // non‑playoff teams: assign bubble, longshot etc.  Use winPct for rough probability.
                if (t.winPct >= 0.55) {
                    t.status = 'Bubble';
                    t.playoffChance = Math.round(40 + t.winPct * 20); // 50–60%
                } else if (t.winPct >= 0.4) {
                    t.status = 'Longshot';
                    t.playoffChance = Math.round(10 + t.winPct * 20); // ~20–30%
                } else {
                    t.status = 'Needs miracle run';
                    t.playoffChance = Math.round(5 + t.winPct * 15); // <15%
                }
                t.tagType = 'out';
                t.seed = '-';
            }
        });
        return list;
    }

    /** Render the standings table into the DOM. */
    function renderStandings(list) {
        // sort by rank
        list.sort((a, b) => a.rank - b.rank);
        const tbody = document.getElementById('standings-body');
        tbody.innerHTML = '';
        list.forEach(team => {
            const tr = document.createElement('tr');
            const values = [team.rank, team.name, team.seed, divisionMap[team.div], team.record,
                team.pf.toFixed(2), team.pa.toFixed(2), team.playoffChance + '%'];
            values.forEach((val, idx) => {
                const td = document.createElement('td');
                td.textContent = val;
                if (idx === 1) td.className = 'team-name';
                tr.appendChild(td);
            });
            const statusTd = document.createElement('td');
            const span = document.createElement('span');
            span.className = 'tag ' + team.tagType;
            span.textContent = team.status;
            statusTd.appendChild(span);
            tr.appendChild(statusTd);
            tbody.appendChild(tr);
        });
    }

    /** Populate the head‑to‑head lookup dropdowns with all team names. */
    function populateDropdowns(list) {
        const selectA = document.getElementById('teamA');
        const selectB = document.getElementById('teamB');
        // clear existing options
        selectA.innerHTML = '';
        selectB.innerHTML = '';
        list.forEach(t => {
            const optA = document.createElement('option');
            optA.value = t.name;
            optA.textContent = t.name;
            selectA.appendChild(optA);
            const optB = document.createElement('option');
            optB.value = t.name;
            optB.textContent = t.name;
            selectB.appendChild(optB);
        });
        if (list.length >= 2) {
            selectA.value = list[0].name;
            selectB.value = list[1].name;
        }
    }

    /** Show the head‑to‑head results for the selected pair of teams. */
    function showHeadToHead() {
        const teamA = document.getElementById('teamA').value;
        const teamB = document.getElementById('teamB').value;
        const resultDiv = document.getElementById('h2h-result');
        if (!scheduleData || scheduleData.length === 0) {
            resultDiv.textContent = 'Schedule data not loaded yet. Make sure schedule.json exists and reload.';
            return;
        }
        if (teamA === teamB) {
            resultDiv.textContent = 'Pick two different teams to see a matchup.';
            return;
        }
        const games = scheduleData.filter(g => {
            const involves = (g.home === teamA && g.away === teamB) || (g.home === teamB && g.away === teamA);
            const finished = g.homeScore !== null && g.awayScore !== null;
            return involves && finished;
        });
        if (games.length === 0) {
            resultDiv.textContent = `${teamA} and ${teamB} have no completed games in schedule.json.`;
            return;
        }
        let aWins = 0, aLosses = 0, aTies = 0;
        const breakdown = [];
        games.forEach(g => {
            const aIsHome = g.home === teamA;
            const aScore = aIsHome ? g.homeScore : g.awayScore;
            const bScore = aIsHome ? g.awayScore : g.homeScore;
            let outcome;
            if (aScore > bScore) {
                aWins++;
                outcome = `${teamA} W`;
            } else if (aScore < bScore) {
                aLosses++;
                outcome = `${teamA} L`;
            } else {
                aTies++;
                outcome = 'T';
            }
            breakdown.push(
                `Week ${g.week}: ${g.away} ${g.awayScore.toFixed(2)} @ ${g.home} ${g.homeScore.toFixed(2)} – ${outcome}`
            );
        });
        const recordStr = `${teamA} vs ${teamB}: ${aWins}-${aLosses}` + (aTies ? `-${aTies}` : '');
        resultDiv.innerHTML = recordStr + '<br>' + breakdown.join('<br>');
    }

    /** Generate explanatory bullet points for how the seeds were determined. */
    function renderTiebreakerNotes(list) {
        const ul = document.getElementById('tiebreak-list');
        ul.innerHTML = '';
        // pick out seeds 1–5
        const seeds = {};
        list.forEach(t => { if (t.seed && t.seed !== '-') seeds[t.seed] = t; });
        const s1 = seeds[1], s2 = seeds[2], s3 = seeds[3], s4 = seeds[4], s5 = seeds[5];
        // Division winners line
        if (s1 && s2) {
            const li = document.createElement('li');
            li.innerHTML = `<strong>Division winners</strong> auto‑lock top 2 seeds: <em>${s1.name}</em> (${divisionMap[s1.div]}) and <em>${s2.name}</em> (${divisionMap[s2.div]}). ${s1.name} is the #1 seed based on record/tie‑breakers.`;
            ul.appendChild(li);
        }
        // #3 seed
        if (s3) {
            const li = document.createElement('li');
            li.innerHTML = `<strong>${s3.name}</strong> (${s3.record}) is the best non‑division winner → #3 seed. Seeds <strong>1–3 all get byes</strong>.`;
            ul.appendChild(li);
        }
        // #4 and #5
        if (s4 && s5) {
            const li = document.createElement('li');
            li.innerHTML = `<strong>${s4.name}</strong> and <strong>${s5.name}</strong> (${s4.record} &amp; ${s5.record}) are seeds #4 and #5. ${s4.name} is above ${s5.name} based on tie‑breakers (PF).`;
            ul.appendChild(li);
        }
        // remainder
        const li = document.createElement('li');
        li.textContent = 'Everyone else is chasing those top 5 spots.';
        ul.appendChild(li);
    }

    /** Render the bracket SVG based on the seeded teams.  This uses
     * absolute line segments to draw a simple bracket with pure lines.
     */
    function renderBracket(list) {
        const container = document.getElementById('bracket-container');
        // identify seeds 1–5
        const seeds = {};
        list.forEach(t => {
            if (t.seed && t.seed !== '-') seeds[t.seed] = t;
        });
        // If fewer than 5 seeds exist (e.g., early in season), fill with placeholders
        function nameOrBlank(s) {
            return s && s.name ? `(${s.seed}) ${s.name}` : '(?) TBD';
        }
        const s1 = seeds[1], s2 = seeds[2], s3 = seeds[3], s4 = seeds[4], s5 = seeds[5];
        // Build SVG markup.  The y‑coordinates mirror the static example and work well on mobile as well.
        const svg = `
<svg viewBox="0 0 900 260" class="bracket-svg">
    <!-- ROUND 1: #4 vs #5 -->
    <text x="15"  y="40"  class="svg-team">${nameOrBlank(s4)}</text>
    <text x="15"  y="90"  class="svg-team">${nameOrBlank(s5)}</text>
    <line x1="220" y1="30" x2="320" y2="30" class="svg-line"/>
    <line x1="220" y1="80" x2="320" y2="80" class="svg-line"/>
    <line x1="320" y1="30" x2="320" y2="80" class="svg-line"/>
    <line x1="320" y1="55" x2="450" y2="55" class="svg-line"/>
    <text x="330" y="48" class="svg-label">Winner 4 vs 5</text>
    <!-- SEMI A: #1 vs Winner 4/5 -->
    <text x="470" y="140" class="svg-team">${nameOrBlank(s1)}</text>
    <line x1="450" y1="55"  x2="450" y2="140" class="svg-line"/>
    <line x1="450" y1="140" x2="650" y2="140" class="svg-line"/>
    <text x="460" y="115" class="svg-label">Semi A: #1 vs Winner 4/5</text>
    <text x="460" y="129" class="svg-label">#1 seed had first round bye</text>
    <!-- SEMI B: #2 vs #3 -->
    <text x="15"  y="180" class="svg-team">${nameOrBlank(s2)}</text>
    <text x="15"  y="230" class="svg-team">${nameOrBlank(s3)}</text>
    <line x1="220" y1="170" x2="360" y2="170" class="semi-line"/>
    <line x1="220" y1="220" x2="360" y2="220" class="semi-line"/>
    <line x1="360" y1="170" x2="360" y2="220" class="semi-line"/>
    <line x1="360" y1="195" x2="650" y2="195" class="semi-line"/>
    <text x="370" y="190" class="svg-label">Semi B: (2) vs (3)</text>
    <text x="370" y="204" class="svg-label">both were byes in Round 1</text>
    <!-- CHAMPIONSHIP -->
    <line x1="650" y1="140" x2="650" y2="195" class="champ-line"/>
    <line x1="650" y1="167" x2="880" y2="167" class="champ-line"/>
    <text x="720" y="160" class="champ-text">Championship</text>
    <text x="720" y="180" class="champ-subtext">Highest remaining vs lowest remaining seed</text>
</svg>`;
        container.innerHTML = svg;
    }

    /** Compute the latest week with completed games and update the badge. */
    function updateWeekBadge() {
        const badge = document.getElementById('week-badge');
        if (!scheduleData || scheduleData.length === 0) {
            badge.textContent = 'No data';
            return;
        }
        let maxWeek = 0;
        scheduleData.forEach(g => {
            if (g.homeScore != null && g.awayScore != null) {
                if (g.week > maxWeek) maxWeek = g.week;
            }
        });
        if (maxWeek === 0) {
            badge.textContent = 'Preseason';
        } else {
            badge.textContent = `Week ${maxWeek} Snapshot`;
        }
    }

    // Entry point
    document.addEventListener('DOMContentLoaded', async () => {
        await loadSchedule();
        teams = computeStandings();
        renderStandings(teams);
        populateDropdowns(teams);
        renderTiebreakerNotes(teams);
        renderBracket(teams);
        updateWeekBadge();
    });
</script>
</body>
</html>